---
title: "12. Tidy data"
output:
  html_document:
    toc: true
    toc_depth: 3
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

### 12.2.1 Exercises

1.  Using prose, describe how the variables and observations are organised in
    each of the sample tables.

In `table1`, each variable has its own column, each observation its own row, and each value its own cell. Therefore, `table1` is a tidy dataset.

In `table2`, the `cases` and `population` do not have their own columns, but rather, are treated as values. `table3` does not have the `cases` and `population` variables stored separately. Instead, both are stored as part of a calculation under `rate`. `table4a` stores the values of the `year` variable as separate variables (with their own columns), with the values being the number of cases (population is missing). `table 4b` is similar, but uses `population` for the values rather than `cases`.

2.  Compute the `rate` for `table2`, and `table4a` + `table4b`. 
    You will need to perform four operations:

    1.  Extract the number of TB cases per country per year.
    2.  Extract the matching population per country per year.
    3.  Divide cases by population, and multiply by 10000.
    4.  Store back in the appropriate place.
    
    Which representation is easiest to work with? Which is hardest? Why?
    
Extract the number of TB cases per country per year:

```{r}
table2_cases <- filter(table2, type == "cases")[["count"]]
```

Extract the matching population per country per year:

```{r}
table2_population <- filter(table2, type == "population")[["count"]]
```

Divide cases by population, and multiply by 10000:

```{r}
table2_rate <- table2_cases / table2_population * 10000
```

Store back in the appropriate place:

```{r}
table2_country <- filter(table2, type == "cases")[["country"]]
table2_year <- filter(table2, type == "cases")[["year"]]

table2_new <- tibble(
  country = table2_country,
  year = table2_year,
  cases = table2_cases,
  population = table2_population,
  rate = table2_rate
  )
table2_new
```

For `table4a` and `table4b`:

```{r}
table4_new <- tibble(
  country = table4a[["country"]],
  `1999` = table4a[["1999"]] / table4b[["1999"]] * 10000,
  `2000` = table4a[["2000"]] / table4b[["2000"]] * 10000
  )
table4_new
```


3.  Recreate the plot showing change in cases over time using `table2`
    instead of `table1`. What do you need to do first?

Filter `cases`:

```{r}
table2 %>%
  filter(type == "cases") %>% 
  ggplot(aes(year, count)) +
    geom_line(aes(group = country)) +
    geom_point(aes(colour = country))
```

### 12.3.3 Exercises

1.  Why are `gather()` and `spread()` not perfectly symmetrical?  
    Carefully consider the following example:
    
    ```{r, results = 'hide'}
    stocks <- tibble(
      year   = c(2015, 2015, 2016, 2016),
      half  = c(   1,    2,     1,    2),
      return = c(1.88, 0.59, 0.92, 0.17)
    )
    stocks %>% 
      spread(year, return) %>% 
      gather("year", "return", `2015`:`2016`)
    ```
    
    (Hint: look at the variable types and think about column _names_.)
    
    Both `spread()` and `gather()` have a `convert` argument. What does it 
    do?

`gather()` and `spread()` are not perfectly symmetrical because variable type is not retained when using both functions, as seen in the example above. In `stocks`, `year` is numeric:

```{r}
stocks %>% select(year)
```

However, after using the `spread()` and `gather()` functions it becomes `character`:

```{r}
stocks %>% 
  spread(year, return) %>% 
  gather("year", "return", `2015`:`2016`) %>% 
  select(year)
```

The `convert` argument, when set to `TRUE`, will retain numeric, integer, or logical column types when using `spread()` or `gather()`.

2.  Why does this code fail?

    ```{r, error = TRUE}
    table4a %>% 
      gather(1999, 2000, key = "year", value = "cases")
    ```

"1999" and "2000" are non-syntactic names so they have to be surrounded by backticks.

```{r}
table4a %>% 
  gather(`1999`, `2000`, key = "year", value = "cases")
```

3.  Why does spreading this tibble fail? How could you add a new column to fix
    the problem?

    ```{r}
    people <- tribble(
      ~name,             ~key,    ~value,
      #-----------------|--------|------
      "Phillip Woods",   "age",       45,
      "Phillip Woods",   "height",   186,
      "Phillip Woods",   "age",       50,
      "Jessica Cordero", "age",       37,
      "Jessica Cordero", "height",   156
    )
    ```

```{r, error = TRUE}
people %>% spread(key, value)
```

Phillip Woods' age has been entered twice. You could add a new column that indicates the time of observation:

```{r}
people <- tribble(
  ~name,             ~key,    ~value, ~time,
  #-----------------|--------|------|-------
  "Phillip Woods",   "age",       45, 1,
  "Phillip Woods",   "height",   186, 1,
  "Phillip Woods",   "age",       50, 2,
  "Jessica Cordero", "age",       37, 1,
  "Jessica Cordero", "height",   156, 1
)
```

```{r}
people %>% spread(key, value)
```

4.  Tidy the simple tibble below. Do you need to spread or gather it?
    What are the variables?

    ```{r}
    preg <- tribble(
      ~pregnant, ~male, ~female,
      "yes",     NA,    10,
      "no",      20,    12
    )
    ```

It needs to be gathered. The variables are sex (male or female) and pregnant (yes or no).

```{r}
preg %>% gather(
  male, female,
  key = "sex",
  value = "count"
)
```

### 12.4.3 Exercises

1.  What do the `extra` and `fill` arguments do in `separate()`? 
    Experiment with the various options for the following two toy datasets.

    ```{r, eval = FALSE}
    tibble(x = c("a,b,c", "d,e,f,g", "h,i,j")) %>% 
      separate(x, c("one", "two", "three"))
    
    tibble(x = c("a,b,c", "d,e", "f,g,i")) %>% 
      separate(x, c("one", "two", "three"))
    ```

`extra` controls what happens when you use a character vector in `sep` and there are too many pieces.

```{r}
tibble(x = c("a,b,c", "d,e,f,g", "h,i,j")) %>% 
  separate(x, c("one", "two", "three"), extra = "merge")
```

In comparison, `fill` controls what happens when there are not enough pieces.

```{r}
tibble(x = c("a,b,c", "d,e", "f,g,i")) %>% 
  separate(x, c("one", "two", "three"), fill = "left")
```

2.  Both `unite()` and `separate()` have a `remove` argument. What does it
    do? Why would you set it to `FALSE`?

It removes the input column from the data frame. By setting this to `FALSE`, you can retain the original input column in the dataset:

```{r}
tibble(x = c("a,b,c", "d,e,f", "g,h,i")) %>% 
  separate(x, c("one", "two", "three"), remove = "FALSE")
```

3.  Compare and contrast `separate()` and `extract()`.  Why are there
    three variations of separation (by position, by separator, and with
    groups), but only one unite?

```{r}
tibble(x = c("a,b,c", "d,e,f", "g,h,i")) %>% 
  separate(x, c("one", "two", "three"))

tibble(x = c("a,b,c", "d,e,f", "g,h,i"))

tibble(x = c("a,b,c", "d,e,f", "g,h,i")) %>% 
  extract(x, "A")
```

`separate()` pulls apart one column and places the values into many columns. `extract()` is a similar function, but, as its name implies, only retains values you wish to extract from a data frame.

`unite()` only requires one variation of separation because it is combining multiple columns into one column. Therefore, there is only one way to do it (using `sep`). In comparison, there are multiple ways to split a character string for `separate()` (e.g., by position or by separator).

### 12.5.1 Exercises

1.  Compare and contrast the `fill` arguments to `spread()` and `complete()`.

For `spread()`, `fill` will replace missing values in a data set with this value. In comparison, the `fill` argument for `complete()` allows you to replace missing values by column name.

2.  What does the direction argument to `fill()` do?

It is the direction in which to fill missing values. For example:

```{r}
df <- data.frame(Month = 1:12, Year = c(NA, 2000, rep(NA, 10)))
df %>% fill(Year, .direction = c("up"))
```

### 12.6.1 Exercises

1.  In this case study I set `na.rm = TRUE` just to make it easier to
    check that we had the correct values. Is this reasonable? Think about
    how missing values are represented in this dataset. Are there implicit
    missing values? What's the difference between an `NA` and zero? 
    
I think this is reasonable. Missing values appear to be represented explicitely in this dataset:
    
```{r}
who %>%
  gather(new_sp_m014:newrel_f65, key = "key", value = "cases") %>% 
  count(is.na(cases))
```

There are over 76,000 `NA` values for `cases`.
    
It is difficult to determine whether there are implicit missing values in a dataset because, as stated earlier in the chapter, implicit missing values are an "absence of a presence".
    
`NA` indicates an explicit missing value. So, the number of actual cases for an `NA` observation is not necessarily zero. In comparison, a value of zero indicates there were no cases for a particular observation.
    
```{r}
who %>%
  gather(new_sp_m014:newrel_f65, key = "key", value = "cases") %>% 
  filter(cases == 0) %>% 
  nrow()
```
    
2.  What happens if you neglect the `mutate()` step?
    (`mutate(key = stringr::str_replace(key, "newrel", "new_rel"))`)
    
```{r}
who %>%
  gather(code, value, new_sp_m014:newrel_f65, na.rm = TRUE) %>% 
  separate(code, c("new", "var", "sexage")) %>% 
  select(-new, -iso2, -iso3) %>% 
  separate(sexage, c("sex", "age"), sep = 1)
```
    
It won't split the string `newrel` properly.
    
```{r}
split_problem <- who %>%
  gather(code, value, new_sp_m014:newrel_f65, na.rm = TRUE) %>% 
  separate(code, c("new", "var", "sexage")) %>% 
  select(-new, -iso2, -iso3) %>% 
  separate(sexage, c("sex", "age"), sep = 1)
```

```{r}
split_problem %>% slice(73467:73486)
```

For relapse cases, gender and age group have not separated (they appear under `var`), and `sex` and `age` variables are `NA`.

3.  I claimed that `iso2` and `iso3` were redundant with `country`. 
    Confirm this claim.

For each country, there is only one unique combination of `iso2` and `iso3`:

```{r}
who %>% 
  gather(new_sp_m014:newrel_f65, key = "key", value = "cases", na.rm = TRUE) %>% 
  select(country, iso2, iso3) %>% 
  distinct() %>% 
  group_by(country) %>% 
  filter(n() > 1)
```
    
4.  For each country, year, and sex compute the total number of cases of 
    TB. Make an informative visualisation of the data.
    
```{r}
who_cases <- who %>%
  gather(code, value, new_sp_m014:newrel_f65, na.rm = TRUE) %>% 
  mutate(code = stringr::str_replace(code, "newrel", "new_rel")) %>%
  separate(code, c("new", "var", "sexage")) %>% 
  select(-new, -iso2, -iso3) %>% 
  separate(sexage, c("sex", "age"), sep = 1) %>% 
  group_by(country, year, sex) %>% 
  summarise(cases = sum(value))

who_cases
```

```{r}
who_cases %>% 
  group_by(sex, year) %>%
  filter(year > 1995) %>% 
  summarise(cases_total = sum(cases)) %>%
  ggplot(aes(x = year, y = cases_total, group = sex, colour = sex)) +
    geom_line()
```