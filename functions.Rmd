---
title: "19. Functions"
output: html_document
---

***

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
library(tidyverse)
```

### 19.2.1 Practice

1. Why is TRUE not a parameter to rescale01()? What would happen if x contained a single missing value, and na.rm was FALSE?

* Because it is a non-numeric argument

```{r, error=TRUE}
x <- c(1:10, Inf, NA)

rescale01 <- function(x) {
  rng <- range(x, na.rm = FALSE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(x)
```

2. In the second variant of rescale01(), infinite values are left unchanged. Rewrite rescale01() so that -Inf is mapped to 0, and Inf is mapped to 1.

3. Practice turning the following code snippets into functions. Think about what each function does. What would you call it? How many arguments does it need? Can you rewrite it to be more expressive or less duplicative?

```{r}
# Calculates the proportion of missing values in a vector
mean(is.na(x))

# Calculates the weight of a value
x / sum(x, na.rm = TRUE)

# Calculates the coefficient of variation
sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
```

```{r}
x <- c(1, 5, 7, NA)

prop_na <- function(x) {
  mean(is.na(x))
}
prop_na(x)

div_sum <- function(x) {
  x / sum(x, na.rm = TRUE)
}

coef_var <- function(x) {
  sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
}
```

